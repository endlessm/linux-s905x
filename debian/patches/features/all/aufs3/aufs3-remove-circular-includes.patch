From: Ian Campbell <ijc@hellion.org.uk>
Date: Sun, 20 Jul 2014 16:13:35 +0100
Subject: aufs3: remove include of linux/fs.h from linux/mm.h
Forwarded: http://sourceforge.net/p/aufs/mailman/message/32628514/

This include is added by aufs3-mmap.patch but causes circular dependencies on
arm64 as seen with the Debian kernel packages in http://buildd.debian-ports.org/status/fetch.php?pkg=linux&arch=arm64&ver=3.14.12-1&stamp=1405234443 which contains:

In file included from /«PKGBUILDDIR»/include/linux/mm.h:23:0,
                 from /«PKGBUILDDIR»/include/linux/pid_namespace.h:6,
                 from /«PKGBUILDDIR»/include/linux/ptrace.h:9,
                 from /«PKGBUILDDIR»/arch/arm64/include/asm/compat.h:26,
                 from /«PKGBUILDDIR»/arch/arm64/include/asm/stat.h:23,
                 from /«PKGBUILDDIR»/include/linux/stat.h:5,
                 from /«PKGBUILDDIR»/include/linux/module.h:10,
                 from /«PKGBUILDDIR»/init/main.c:15:
/«PKGBUILDDIR»/include/linux/fs.h:1575:64: warning: 'struct kstat' declared inside parameter list [enabled by default]
  int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);

According to http://article.gmane.org/gmane.linux.ports.arm.kernel/342042
> The added mm.h->fs.h looks like a mistake, it should not be there, and we have
> in the past worked hard to separate mm.h, sched.h and fs.h from one another.

Move all of the static inline functions added to mm.h by
aufs3-mmap.patch into a new file, mm/aufs_mmap.c, instead to avoid the
new includes in mm.h.

Signed-off-by: Ian Campbell <ijc@hellion.org.uk>

--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -18,9 +18,6 @@
 #include <linux/pfn.h>
 #include <linux/bit_spinlock.h>
 #include <linux/shrinker.h>
-#include <linux/dcache.h>
-#include <linux/file.h>
-#include <linux/fs.h>
 
 struct mempolicy;
 struct anon_vma;
@@ -1155,76 +1152,16 @@
 }
 #endif
 
-/*
- * Mainly for aufs which mmap(2) diffrent file and wants to print different path
- * in /proc/PID/maps.
- */
-/* #define AUFS_DEBUG_MMAP */
-static inline void aufs_trace(struct file *f, struct file *pr,
-			      const char func[], int line, const char func2[])
-{
-#ifdef AUFS_DEBUG_MMAP
-	if (pr)
-		pr_info("%s:%d: %s, %p\n", func, line, func2,
-			f ? (char *)f->f_dentry->d_name.name : "(null)");
-#endif
-}
-
-static inline struct file *vmr_do_pr_or_file(struct vm_region *region,
-					     const char func[], int line)
-{
-	struct file *f = region->vm_file, *pr = region->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	return (f && pr) ? pr : f;
-}
-
-static inline void vmr_do_fput(struct vm_region *region,
-			       const char func[], int line)
-{
-	struct file *f = region->vm_file, *pr = region->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	fput(f);
-	if (f && pr)
-		fput(pr);
-}
-
-static inline void vma_do_file_update_time(struct vm_area_struct *vma,
-					   const char func[], int line)
-{
-	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	file_update_time(f);
-	if (f && pr)
-		file_update_time(pr);
-}
-
-static inline struct file *vma_do_pr_or_file(struct vm_area_struct *vma,
-					     const char func[], int line)
-{
-	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	return (f && pr) ? pr : f;
-}
-
-static inline void vma_do_get_file(struct vm_area_struct *vma,
-				   const char func[], int line)
-{
-	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	get_file(f);
-	if (f && pr)
-		get_file(pr);
-}
-
-static inline void vma_do_fput(struct vm_area_struct *vma,
-			       const char func[], int line)
-{
-	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
-	aufs_trace(f, pr, func, line, __func__);
-	fput(f);
-	if (f && pr)
-		fput(pr);
-}
+extern struct file *vmr_do_pr_or_file(struct vm_region *region,
+				      const char func[], int line);
+extern void vmr_do_fput(struct vm_region *region, const char func[], int line);
+extern void vma_do_file_update_time(struct vm_area_struct *vma,
+				    const char func[], int line);
+extern struct file *vma_do_pr_or_file(struct vm_area_struct *vma,
+				      const char func[], int line);
+extern void vma_do_get_file(struct vm_area_struct *vma,
+			    const char func[], int line);
+extern void vma_do_fput(struct vm_area_struct *vma, const char func[], int line);
 
 #define vmr_pr_or_file(region)		vmr_do_pr_or_file(region, __func__, \
 							  __LINE__)
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -20,6 +20,7 @@
 			   interval_tree.o list_lru.o $(mmu-y)
 
 obj-y += init-mm.o
+obj-y += aufs_mmap.o
 
 ifdef CONFIG_NO_BOOTMEM
 	obj-y		+= nobootmem.o
--- /dev/null
+++ b/mm/aufs_mmap.c
@@ -0,0 +1,73 @@
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+
+/*
+ * Mainly for aufs which mmap(2) diffrent file and wants to print different path
+ * in /proc/PID/maps.
+ */
+/* #define AUFS_DEBUG_MMAP */
+static inline void aufs_trace(struct file *f, struct file *pr,
+			      const char func[], int line, const char func2[])
+{
+#ifdef AUFS_DEBUG_MMAP
+	if (pr)
+		pr_info("%s:%d: %s, %p\n", func, line, func2,
+			f ? (char *)f->f_dentry->d_name.name : "(null)");
+#endif
+}
+
+#ifndef CONFIG_MMU
+struct file *vmr_do_pr_or_file(struct vm_region *region,
+			       const char func[], int line)
+{
+	struct file *f = region->vm_file, *pr = region->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	return (f && pr) ? pr : f;
+}
+
+void vmr_do_fput(struct vm_region *region, const char func[], int line)
+{
+	struct file *f = region->vm_file, *pr = region->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	fput(f);
+	if (f && pr)
+		fput(pr);
+}
+#endif
+
+void vma_do_file_update_time(struct vm_area_struct *vma,
+			     const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	file_update_time(f);
+	if (f && pr)
+		file_update_time(pr);
+}
+
+struct file *vma_do_pr_or_file(struct vm_area_struct *vma,
+			       const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	return (f && pr) ? pr : f;
+}
+
+void vma_do_get_file(struct vm_area_struct *vma, const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	get_file(f);
+	if (f && pr)
+		get_file(pr);
+}
+
+void vma_do_fput(struct vm_area_struct *vma, const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	fput(f);
+	if (f && pr)
+		fput(pr);
+}
